<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>후보 당선 확률 차트</title>
  <style>
    /* 개선된 반응형 스타일 */
    :root {
      --background-color: #f8f9fa;
      --container-bg: white;
      --text-color: #333;
      --border-color: #ddd;
      --header-color: #1a73e8;
      --button-color: #1a73e8;
      --button-hover: #0d47a1;
      --footer-color: #666;
      --spinner-border: #f3f3f3;
      --spinner-top: #1a73e8;
      --box-shadow: rgba(0,0,0,0.1);
    }
    
    .dark-mode {
      --background-color: #121212;
      --container-bg: #1e1e1e;
      --text-color: #e0e0e0;
      --border-color: #444;
      --header-color: #4dabf7;
      --button-color: #4dabf7;
      --button-hover: #74c0fc;
      --footer-color: #adb5bd;
      --spinner-border: #333;
      --spinner-top: #4dabf7;
      --box-shadow: rgba(0,0,0,0.3);
    }
    
    body {
      font-family: 'Noto Sans KR', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: var(--container-bg);
      border-radius: 10px;
      box-shadow: 0 2px 10px var(--box-shadow);
      transition: background-color 0.3s, box-shadow 0.3s;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: var(--header-color);
      transition: color 0.3s;
    }
    
    .chart-container {
      position: relative;
      margin: auto;
      height: 70vh;
      width: 100%;
      padding: 10px;
    }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
    
    .loading-spinner {
      border: 5px solid var(--spinner-border);
      border-top: 5px solid var(--spinner-top);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
      transition: border-color 0.3s;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
    }
    
    .date-range {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 20px;
      justify-content: center;
    }
    
    .date-range label {
      font-weight: bold;
    }
    
    .date-range input {
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--container-bg);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    
    button {
      background-color: var(--button-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: var(--button-hover);
    }
    
    .candidate-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    
    .legend-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      padding: 10px;
      border-radius: 8px;
      transition: all 0.2s;
      width: 100px;
    }
    
    .legend-item:hover {
      background-color: var(--background-color);
      transform: translateY(-2px);
    }
    
    .legend-image {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      margin-bottom: 8px;
      border: 3px solid transparent;
      transition: border-color 0.2s;
    }
    
    .legend-item.inactive .legend-image {
      opacity: 0.5;
    }
    
    .legend-color {
      display: none; /* 기존 색상 박스 숨김 */
    }
    
    .legend-text {
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      margin-bottom: 4px;
    }
    
    .legend-percentage {
      font-size: 16px;
      font-weight: bold;
      color: var(--header-color);
    }
    
    .legend-item.inactive .legend-percentage {
      opacity: 0.5;
    }
    
    footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: var(--footer-color);
      transition: color 0.3s;
    }
    
    .theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .theme-toggle-button {
      background-color: var(--button-color);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background-color 0.3s;
    }
    
    .theme-toggle-button:hover {
      background-color: var(--button-hover);
    }
    
    .theme-icon {
      font-size: 16px;
    }
    
    @media (max-width: 768px) {
      .chart-container {
        height: 60vh;
        padding: 5px;
      }
      
      h1 {
        font-size: 1.2rem;
        margin-bottom: 15px;
      }
      
      .theme-toggle {
        top: 10px;
        right: 10px;
      }
      
      .theme-toggle-button {
        padding: 5px 8px;
        font-size: 12px;
      }
      
      .date-range {
        flex-direction: column;
        align-items: stretch;
        margin-bottom: 10px;
        gap: 5px;
      }
      
      .date-range input, 
      .date-range button {
        margin: 2px 0;
        height: 36px;
        font-size: 13px;
      }
      
      .controls button {
        padding: 6px 10px;
        font-size: 13px;
      }
      
      /* 레전드 아이템 크기 축소 */
      .legend-item {
        padding: 5px;
        width: 70px;
        margin-bottom: 5px;
      }
      
      .legend-item .legend-image,
      .legend-item div[style*="border-radius: 50%"] {
        width: 40px !important;
        height: 40px !important;
        margin-bottom: 4px;
      }
      
      .legend-item .legend-text {
        font-size: 12px;
        margin-bottom: 2px;
      }
      
      .legend-item .legend-percentage {
        font-size: 13px;
      }
      
      /* 후보자 레전드 간격 줄이기 */
      .candidate-legend > div {
        gap: 8px !important;
      }
      
      .container {
        padding: 10px;
      }
    }
    
    /* 매우 작은 화면에서 추가 축소 */
    @media (max-width: 480px) {
      .legend-item {
        width: 60px;
      }
      
      .legend-item .legend-image,
      .legend-item div[style*="border-radius: 50%"] {
        width: 35px !important;
        height: 35px !important;
      }
    }
  </style>
  <!-- Google Fonts - Noto Sans KR -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="theme-toggle">
    <button id="themeToggle" class="theme-toggle-button">
      <span class="theme-icon">🌙</span> 다크모드
    </button>
  </div>
  <div class="container">
    <h1>2025 대선 후보별 당선 확률 트렌드</h1>
    
    <div class="date-range">
      <label for="startDate">시작일:</label>
      <input type="date" id="startDate">
      <label for="endDate">종료일:</label>
      <input type="date" id="endDate">
      <button id="applyDateFilter">적용</button>
      <button id="resetDateFilter">초기화</button>
      <button id="lastWeek">직전 일주일</button>
      <button id="last30Days">직전 30일</button>
      <button id="last3Months">직전 3개월</button>
    </div>
    
    <div class="candidate-legend" id="candidateLegend">
      <!-- 자바스크립트로 동적 생성됨 -->
    </div>
    
    <div class="chart-container">
      <div id="loadingIndicator" class="loading">
        <div class="loading-spinner"></div>
        <p>데이터를 불러오는 중입니다...</p>
      </div>
      <canvas id="electionChart"></canvas>
    </div>
    
    <div class="controls">
      <button id="toggleAllCandidates">모든 후보 표시/숨김</button>
    </div>
    
    <footer>
      데이터 출처: Google Sheets 공개 CSV | 마지막 업데이트: <span id="lastUpdate">로딩 중...</span>
      <div class="disclaimer" style="margin-top: 15px; font-size: 11px; line-height: 1.4; color: var(--footer-color); max-width: 800px; margin-left: auto; margin-right: auto; text-align: justify;">
        본 웹사이트에 제공되는 모든 데이터 및 정보는 공개된 자료를 토대로 수집 및 가공된 것으로, 그 정확성, 신뢰성 및 완전성에 대해 어떠한 보증도 하지 않습니다. 이용자는 본 데이터를 전적으로 자신의 판단과 책임 하에 활용하며, 이로 인하여 발생하는 모든 법적 문제 및 손해에 대해서는 웹사이트 운영자 및 관련 당사자가 책임지지 않습니다. 또한, 데이터의 저작권, 사용 권한 및 기타 법적 이슈와 관련하여 사전 통지 없이 변경될 수 있음을 명시하며, 별도의 명시적 합의가 없는 한 모든 법적 책임은 이용자에게 있음을 알려드립니다.
      </div>
    </footer>
  </div>

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Chart.js Datalabels 플러그인 (CDN) - 버전 변경 및 위치 조정 -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
  <!-- Papa Parse (CSV 파싱용, CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <!-- 날짜 포맷팅을 위한 Day.js -->
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/locale/ko.js"></script>

  <script>
    // Chart.js Datalabels 플러그인 전역 변수 설정 - 오류 처리 추가
    let ChartDataLabels = null;
    try {
      ChartDataLabels = window['chartjs-plugin-datalabels'];
      // 플러그인 등록
      Chart.register(ChartDataLabels);
    } catch (e) {
      console.error("Datalabels 플러그인 로드 오류:", e);
    }
    
    // 다크모드 토글 기능
    const themeToggle = document.getElementById('themeToggle');
    const body = document.body;
    const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    
    // 사용자 시스템 설정이나 로컬 스토리지에서 테마 설정 가져오기
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && prefersDarkScheme.matches)) {
      body.classList.add('dark-mode');
      themeToggle.innerHTML = '<span class="theme-icon">☀️</span> 라이트모드';
    }
    
    themeToggle.addEventListener('click', () => {
      if (body.classList.contains('dark-mode')) {
        body.classList.remove('dark-mode');
        localStorage.setItem('theme', 'light');
        themeToggle.innerHTML = '<span class="theme-icon">🌙</span> 다크모드';
        
        // 차트 테마 업데이트 (라이트모드)
        if (chart) {
          chart.options.scales.x.ticks.color = '#666';
          chart.options.scales.y.ticks.color = '#666';
          chart.options.scales.x.title.color = '#666';
          chart.options.scales.y.title.color = '#666';
          chart.options.plugins.title.color = '#333';
          chart.update();
        }
      } else {
        body.classList.add('dark-mode');
        localStorage.setItem('theme', 'dark');
        themeToggle.innerHTML = '<span class="theme-icon">☀️</span> 라이트모드';
        
        // 차트 테마 업데이트 (다크모드)
        if (chart) {
          chart.options.scales.x.ticks.color = '#adb5bd';
          chart.options.scales.y.ticks.color = '#adb5bd';
          chart.options.scales.x.title.color = '#e0e0e0';
          chart.options.scales.y.title.color = '#e0e0e0';
          chart.options.plugins.title.color = '#e0e0e0';
          chart.update();
        }
      }
    });
    
    // 로딩 인디케이터 표시
    const loadingIndicator = document.getElementById('loadingIndicator');
    
    // Google Sheets 정보
    const spreadsheetId = '1FBkYF5tZDBCFqyg1U-h9TLikdTDA1NUpxIFAGJ7eDvw'; // 실제 스프레드시트 ID
    const sheetName = 'csv'; // 실제 시트 이름
    const apiKey = 'AIzaSyBb2nNqLgPKBnOaWdr5dtAoc1U9Wn6v5IU'; // 실제 API 키

    // Google Sheets API URL
    const sheetsApiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName}?key=${apiKey}`;
    
    // 2) 후보자 컬럼 이름 (CSV 헤더와 동일하게)
    //    "date_day" 외에 실제 후보 이름 컬럼 8개
    const candidateLabels = [
      "이재명", "김동연", "김문수", "한동훈",
      "홍준표", "오세훈", "이준석", "이낙연"
    ];
    
    // 3) 후보자별 색상 지정
    const candidateColors = {
      "이재명": "#152484",
      "김동연": "#4958B0",
      "김문수": "#E61E2B",
      "한동훈": "#FF5C6A",
      "홍준표": "#B71721",
      "오세훈": "#FF8A94",
      "이준석": "#FF7210",
      "이낙연": "#45BABD"
    };
    
    // 후보자별 라인 스타일 설정
    const candidateStyles = {
      "이재명": { borderDash: [], pointStyle: 'circle' },
      "김동연": { borderDash: [10, 5], pointStyle: 'triangle' },
      "김문수": { borderDash: [], pointStyle: 'rect' },
      "한동훈": { borderDash: [5, 5], pointStyle: 'triangle' },
      "홍준표": { borderDash: [15, 3], pointStyle: 'rect' },
      "오세훈": { borderDash: [8, 8], pointStyle: 'star' },
      "이준석": { borderDash: [2, 2], pointStyle: 'circle' },
      "이낙연": { borderDash: [12, 3], pointStyle: 'circle' }
    };
    
    // 후보자별 이미지 URL 업데이트
    const candidateImages = {
      "이재명": "https://i.namu.wiki/i/HRl3tqzehPKPS1ycNmWoijduX-Y8tbda_Tc-TPPwiRt0j67yralDxXTOFbDr1QstdWGIj3BR_wYYbEYOm8JeDthReHTo4wOdf1yWgGRhEoLf-f-u0aC20uhqipZ2kLVpGhruarSsg4jFJAiXrZdTcw.webp",
      "김동연": "https://i.namu.wiki/i/rNjm947tSGuwD8JkqWt7jfR-RhLtLMYqSzA1rNcgbBT63QvJqxSDGuKblhOmkRsDPFQqkSTu59-I72F63T7-GES5DQ1d3WVmhYzO_iomaSL8ckiIX7rqW2tZq1UuttZ58tRtHZoXuwOlFmekyt9uug.webp",
      "김문수": "https://i.namu.wiki/i/IB0A2SrSD5GRod3w6uxKMTkz1yPctPeKla54wtUcc7sdxrEkQjbWIxmkwH0M6gnnfMplo9YZIxRe79jsFhxUhrwLKs-GuLRPFS9POyRBCLLDaofSpK4xsscws4J7b2vQjKIkVvwHjvf4mrhW1Yk2NA.webp",
      "한동훈": "https://i.namu.wiki/i/y4VZDisGo3iS34VAAsTbjSpsbPrJ6Ox5FFVy-LL2rawisQ8yrHr7ZC5Msk1409f3usVAOToVy03N7H9Z1mozYfXk9qeXid-cRZu0BNN-jq38P2pzKeQHxlPdiTRNZR_87Lixo3NvbX3ZgeNJ3VUhFA.webp",
      "홍준표": "https://i.namu.wiki/i/uyc8ltZ5EiLUlTIhXnMcXP3srP0u8aTpvPOy5GbAn-hzXA6ggYHafBWmkuUpQ5-W3PUhcHI1QexFJsjiiM8yQprWQAHTu2XsVevo6on8iQ2XtvqDwcpL7nGZL-_lUkYoeU8YOtKZcfu84qw8wUPykw.webp",
      "오세훈": "https://i.namu.wiki/i/NZs4RwPqxiSbewfz_aZOJTZmuHvAU1JSl8iugfrgLTLNZmmn8xBgkOjjQYWK3QIUEl3bTZRqUuIbNFeniihOhOMIOskoeqvvDg9uVHeECPqMbm_Q5gdODL79GShJykzH1KOBwsvBuMWxbW4DbnQpMA.webp",
      "이준석": "https://i.namu.wiki/i/Kqqk3XNnhU2z-ng5tqtrGmLjU81GOYW_1tcCklq0wZ_xUVUuUmXQgLUVj84UiTZdx0OVnP4RgrhF6zTAuI2Rdpz6MOpq2hamKzJ6jjMWeZew1WDMtw9GjTGtDWGM809m8D_rZxXajFJiU1SrWaErBw.webp",
      "이낙연": "https://i.namu.wiki/i/d2H0Nidrt55samE1Q0R8vXYMmeOR6ZlHKGO799ub5uGEWFqZBfKXZu6AdfA33yE1YdUueZcZM_wi4eadUpwBItRF00EO7kEKN8KUcWJO3S3jXQuLFcS6fFB-lRR9Kuro-stqwwsdOG9a7457EyncQQ.webp"
    };
    
    // 전역 변수
    let chart = null;
    let allData = [];
    let filteredData = [];
    let visibleCandidates = [...candidateLabels];
    let thirtyDaysAgo;
    let lastDate;
    
    // 날짜 형식 변환 (YYYY-MM-DD)
    const formatDate = (date) => {
      return date.toISOString().split('T')[0];
    };
    
    // dayjs 한국어 로케일 설정
    dayjs.locale('ko');
    
    // Google Sheets API를 사용하여 데이터 로드
    // 참고: Google Sheets API를 사용하려면 다음 단계가 필요합니다:
    // 1. Google Cloud Console(https://console.cloud.google.com/)에서 프로젝트 생성
    // 2. Google Sheets API 활성화
    // 3. API 키 생성 (제한사항: HTTP 리퍼러 제한 설정 권장)
    // 4. 생성된 API 키를 위의 apiKey 변수에 입력
    // 5. 스프레드시트 ID와 시트 이름 설정
    //
    // 실제 API 키가 설정되어 있으므로 Google Sheets API를 사용합니다.
    loadDataFromGoogleSheetsApi(); // API를 통해 실제 데이터 로드
    
    // Google Sheets API를 사용하여 데이터 로드 함수
    function loadDataFromGoogleSheetsApi() {
      // 로딩 인디케이터 표시
      loadingIndicator.style.display = 'block';
      loadingIndicator.innerHTML = `
        <div class="loading-spinner"></div>
        <p>Google Sheets API에서 데이터를 불러오는 중입니다...</p>
      `;
      
      fetch(sheetsApiUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP 오류: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          if (data && data.values && data.values.length > 0) {
            // API 응답에서 데이터 추출 및 가공
            const headers = data.values[0];
            const rows = data.values.slice(1);
            
            const parsedData = rows.map(row => {
              const rowData = {};
              headers.forEach((header, index) => {
                rowData[header] = row[index] || '';
              });
              return rowData;
            });
            
            processData(parsedData);
            
            // 마지막 업데이트 날짜만 변경하고 면책조항은 유지
            document.getElementById('lastUpdate').textContent = dayjs(parsedData[0].date_day).format('YYYY년 MM월 DD일');
          } else {
            throw new Error("API 응답에 데이터가 없거나 형식이 올바르지 않습니다.");
          }
        })
        .catch(err => {
          console.error("Google Sheets API 로드 중 오류:", err);
          loadingIndicator.innerHTML = `
            <p>Google Sheets API 데이터 로드 중 오류가 발생했습니다: ${err.message}</p>
            <button id="retryFetch" style="margin-top: 20px;">다시 시도</button>
          `;
          
          document.getElementById('retryFetch').addEventListener('click', () => {
            loadDataFromGoogleSheetsApi();
          });
        });
    }
    
    // 데이터 처리 공통 함수
    function processData(data) {
      allData = data;
      
      // 데이터 정렬 (날짜 내림차순)
      allData.sort((a, b) => {
        return new Date(b["date_day"]) - new Date(a["date_day"]);
      });
      
      // 최근 30일 데이터만 필터링
      lastDate = new Date(allData[0]["date_day"]);
      thirtyDaysAgo = new Date(lastDate);
      thirtyDaysAgo.setDate(lastDate.getDate() - 30);
      
      filteredData = allData.filter(row => {
        const rowDate = new Date(row["date_day"]);
        return rowDate >= thirtyDaysAgo && rowDate <= lastDate;
      });
      
      // 날짜 필터 초기화
      initializeDateFilters();
      
      // 후보자 레전드 생성
      createCandidateLegend();
      
      // 마지막 업데이트 날짜 표시
      updateLastUpdateDate();
      
      // 차트 렌더링
      renderChart(filteredData);
      
      // 로딩 인디케이터 숨기기
      loadingIndicator.style.display = 'none';
    }
    
    // 날짜 필터 초기화
    function initializeDateFilters() {
      if (allData.length === 0) return;
      
      const startDateInput = document.getElementById('startDate');
      const endDateInput = document.getElementById('endDate');
      
      // 데이터의 첫 날짜와 마지막 날짜 가져오기
      const firstDate = new Date(allData[allData.length - 1]["date_day"]);
      
      // 입력 필드에 날짜 설정
      startDateInput.value = formatDate(thirtyDaysAgo);
      endDateInput.value = formatDate(lastDate);
      
      // 데이터가 있는 날짜들을 추출하여 배열로 저장
      const availableDates = allData.map(row => row["date_day"]);
      
      // 날짜 입력 필드에 변경 이벤트 리스너 추가
      startDateInput.addEventListener('input', function() {
        validateDateInput(this, availableDates);
      });
      
      endDateInput.addEventListener('input', function() {
        validateDateInput(this, availableDates);
      });
      
      // 이벤트 리스너 제거 후 다시 추가 (중복 방지)
      document.getElementById('applyDateFilter').removeEventListener('click', applyDateFilter);
      document.getElementById('resetDateFilter').removeEventListener('click', resetDateFilter);
      document.getElementById('lastWeek').removeEventListener('click', () => setDateRange(7));
      document.getElementById('last30Days').removeEventListener('click', () => setDateRange(30));
      document.getElementById('last3Months').removeEventListener('click', () => setDateRange(90));
      
      // 날짜 필터 적용 버튼 이벤트
      document.getElementById('applyDateFilter').addEventListener('click', applyDateFilter);
      
      // 날짜 필터 초기화 버튼 이벤트
      document.getElementById('resetDateFilter').addEventListener('click', resetDateFilter);
      
      // 날짜 범위 버튼 이벤트 추가
      document.getElementById('lastWeek').addEventListener('click', function() { setDateRange(7); });
      document.getElementById('last30Days').addEventListener('click', function() { setDateRange(30); });
      document.getElementById('last3Months').addEventListener('click', function() { setDateRange(90); });
      
      // 사용 가능한 날짜 목록을 설정
      setAvailableDates(startDateInput, availableDates);
      setAvailableDates(endDateInput, availableDates);
    }
    
    // 날짜 입력 필드에 사용 가능한 날짜 설정
    function setAvailableDates(dateInput, availableDates) {
      // 기존 min, max 속성 설정
      const firstAvailableDate = new Date(availableDates[availableDates.length - 1]);
      const lastAvailableDate = new Date(availableDates[0]);
      
      dateInput.min = formatDate(firstAvailableDate);
      dateInput.max = formatDate(lastAvailableDate);
      
      // 사용자 정의 데이터 속성에 사용 가능한 날짜 목록 저장
      dateInput.dataset.availableDates = JSON.stringify(availableDates);
    }
    
    // 날짜 입력 유효성 검사
    function validateDateInput(input, availableDates) {
      const selectedDate = input.value;
      
      // 선택된 날짜가 사용 가능한 날짜 목록에 없으면 가장 가까운 사용 가능한 날짜로 변경
      if (!availableDates.includes(selectedDate)) {
        // 가장 가까운 사용 가능한 날짜 찾기
        const closestDate = findClosestDate(selectedDate, availableDates);
        input.value = closestDate;
        
        // 사용자에게 알림
        alert(`선택하신 날짜(${selectedDate})에는 데이터가 없습니다. 가장 가까운 날짜(${closestDate})로 변경되었습니다.`);
      }
    }
    
    // 가장 가까운 사용 가능한 날짜 찾기
    function findClosestDate(targetDate, availableDates) {
      const target = new Date(targetDate);
      
      // 날짜 차이를 계산하여 가장 가까운 날짜 찾기
      let closestDate = availableDates[0];
      let minDiff = Math.abs(target - new Date(availableDates[0]));
      
      for (let i = 1; i < availableDates.length; i++) {
        const diff = Math.abs(target - new Date(availableDates[i]));
        if (diff < minDiff) {
          minDiff = diff;
          closestDate = availableDates[i];
        }
      }
      
      return closestDate;
    }
    
    // 날짜 필터 적용
    function applyDateFilter() {
      const startDate = new Date(document.getElementById('startDate').value);
      const endDate = new Date(document.getElementById('endDate').value);
      
      // 종료일이 시작일보다 이전이면 경고
      if (endDate < startDate) {
        alert('종료일은 시작일 이후여야 합니다.');
        return;
      }
      
      // 날짜 범위에 맞는 데이터 필터링
      filteredData = allData.filter(row => {
        const rowDate = new Date(row["date_day"]);
        return rowDate >= startDate && rowDate <= endDate;
      });
      
      // 차트 다시 그리기
      renderChart(filteredData);
    }
    
    // 날짜 필터 초기화
    function resetDateFilter() {
      initializeDateFilters();
      filteredData = [...allData];
      renderChart(filteredData);
    }
    
    // 후보자 레전드 생성
    function createCandidateLegend() {
      const legendContainer = document.getElementById('candidateLegend');
      legendContainer.innerHTML = '';
      
      // 후보자 범례를 담을 div 생성
      const candidatesDiv = document.createElement('div');
      candidatesDiv.style.display = 'flex';
      candidatesDiv.style.flexWrap = 'wrap';
      candidatesDiv.style.gap = '15px'; // 기본 간격은 15px
      candidatesDiv.style.justifyContent = 'center';
      
      // 모바일 화면에서는 간격 축소
      if (window.innerWidth <= 768) {
        candidatesDiv.style.gap = '8px';
      }
      
      // 최신 데이터 가져오기
      const latestData = allData[0];
      
      // 후보자를 최신 퍼센트 기준으로 내림차순 정렬
      const sortedCandidates = [...candidateLabels].sort((a, b) => {
        const valueA = parseFloat((latestData[a] || "0%").replace("%", "")) || 0;
        const valueB = parseFloat((latestData[b] || "0%").replace("%", "")) || 0;
        return valueB - valueA; // 내림차순 정렬
      });
      
      // 이미지 크기 - 모바일과 데스크톱 대응
      const imageSize = window.innerWidth <= 768 ? '40px' : '60px';
      
      sortedCandidates.forEach(candidate => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.dataset.candidate = candidate;
        
        // 이미지 컨테이너 수정 - 모바일 대응
        const imageContainer = document.createElement('div');
        imageContainer.style.width = imageSize;
        imageContainer.style.height = imageSize;
        imageContainer.style.borderRadius = '50%';
        imageContainer.style.backgroundColor = candidateColors[candidate];
        imageContainer.style.border = `3px solid ${candidateColors[candidate]}`;
        imageContainer.style.display = 'flex';
        imageContainer.style.alignItems = 'center';
        imageContainer.style.justifyContent = 'center';
        imageContainer.style.marginBottom = '8px';
        imageContainer.style.overflow = 'hidden';
        
        // 이미지 요소 수정 - 툴팁과 동일한 스타일
        const image = new Image();
        image.className = 'legend-image';
        image.src = candidateImages[candidate];
        image.alt = candidate;
        image.style.width = '100%'; // 100%로 변경 (툴팁과 동일)
        image.style.height = '100%'; // 100%로 변경 (툴팁과 동일)
        image.style.objectFit = 'cover';
        image.style.borderRadius = '0'; // 테두리 없앰 (컨테이너가 이미 원형)
        
        // 이미지 로드 실패시 대체 텍스트 표시
        image.onerror = () => {
          imageContainer.innerHTML = `
            <span style="color: white; font-weight: bold; font-size: 20px;">
              ${candidate.charAt(0)}
            </span>
          `;
        };
        
        // 이미지 로드 성공시
        image.onload = () => {
          imageContainer.innerHTML = '';
          imageContainer.appendChild(image);
        };
        
        // 후보자 이름
        const text = document.createElement('span');
        text.className = 'legend-text';
        text.textContent = candidate;
        
        // 최신 퍼센트 값
        const percentage = document.createElement('span');
        percentage.className = 'legend-percentage';
        const latestValue = latestData[candidate] || "0%";
        percentage.textContent = latestValue;
        
        legendItem.appendChild(imageContainer);
        legendItem.appendChild(text);
        legendItem.appendChild(percentage);
        
        // 클릭 이벤트 추가
        legendItem.addEventListener('click', () => {
          toggleCandidate(candidate, legendItem);
          imageContainer.style.borderColor = visibleCandidates.includes(candidate) ? 
            candidateColors[candidate] : 'transparent';
        });
        
        candidatesDiv.appendChild(legendItem);
      });
      
      // 바로 candidatesDiv를 legendContainer에 추가
      legendContainer.appendChild(candidatesDiv);
      
      // 모든 후보 표시/숨김 버튼 이벤트
      document.getElementById('toggleAllCandidates').addEventListener('click', toggleAllCandidates);
    }
    
    // 후보자 표시/숨김 토글
    function toggleCandidate(candidate, legendItem) {
      const index = visibleCandidates.indexOf(candidate);
      
      if (index !== -1) {
        // 후보자 숨기기
        visibleCandidates.splice(index, 1);
        legendItem.classList.add('inactive');
      } else {
        // 후보자 표시
        visibleCandidates.push(candidate);
        legendItem.classList.remove('inactive');
      }
      
      // 차트 업데이트
      updateChartVisibility();
    }
    
    // 모든 후보자 표시/숨김 토글
    function toggleAllCandidates() {
      const legendTexts = document.querySelectorAll('.legend-text');
      
      if (visibleCandidates.length > 0) {
        // 모든 후보자 숨기기
        visibleCandidates = [];
        legendTexts.forEach(text => text.classList.add('inactive'));
      } else {
        // 모든 후보자 표시
        visibleCandidates = [...candidateLabels];
        legendTexts.forEach(text => text.classList.remove('inactive'));
      }
      
      // 차트 업데이트
      updateChartVisibility();
    }
    
    // 차트 가시성 업데이트
    function updateChartVisibility() {
      if (!chart) return;
      
      chart.data.datasets.forEach(dataset => {
        const isVisible = visibleCandidates.includes(dataset.label);
        dataset.hidden = !isVisible;
      });
      
      chart.update();
    }
    
    // 마지막 업데이트 날짜 표시
    function updateLastUpdateDate() {
      if (allData.length === 0) return;
      
      const lastDate = new Date(allData[0]["date_day"]);
      const formattedDate = dayjs(lastDate).format('YYYY년 MM월 DD일');
      
      // lastUpdate 요소만 업데이트하고 면책조항은 유지
      document.getElementById('lastUpdate').textContent = formattedDate;
    }

    // 이미지 캐시를 전역으로 정의 (차트와 툴팁이 공유)
    const candidateImagesCache = {};

    // Chart.js 기본 툴팁을 커스텀 HTML 툴팁으로 대체
    const externalTooltipHandler = (context) => {
      // 툴팁 요소 가져오기
      const {chart, tooltip} = context;
      const tooltipEl = getOrCreateTooltip(chart);

      // 툴팁이 숨겨져 있으면 숨기기
      if (tooltip.opacity === 0) {
        tooltipEl.style.opacity = 0;
        return;
      }

      // 툴팁 데이터 설정
      if (tooltip.body) {
        // 헤더 텍스트 설정
        const titleLines = tooltip.title || [];
        
        // 툴팁 내용 초기화
        const tooltipRoot = tooltipEl.querySelector('.tooltip-content');
        tooltipRoot.innerHTML = '';
        
        // 제목 추가
        const titleElement = document.createElement('div');
        titleElement.style.borderBottom = '1px solid #ddd';
        titleElement.style.marginBottom = '6px';
        titleElement.style.paddingBottom = '4px';
        titleElement.style.fontWeight = 'bold';
        titleElement.style.fontSize = '14px';
        
        // 날짜 제목 텍스트 설정 (기존 형식 유지)
        if (titleLines.length) {
          const dateStr = titleLines[0];
          titleElement.textContent = dateStr;
        }
        
        tooltipRoot.appendChild(titleElement);
        
        // 툴팁 내용 영역
        const bodyContainer = document.createElement('div');
        bodyContainer.style.display = 'flex';
        bodyContainer.style.flexDirection = 'column';
        bodyContainer.style.gap = '6px';
        
        // 정렬할 데이터포인트 배열 복사 (숨겨진 후보자 제외)
        const sortedDataPoints = tooltip.dataPoints
          .filter(dataPoint => !dataPoint.dataset.hidden)
          .slice();
        
        // 내림차순 정렬 (값이 큰 순서대로)
        sortedDataPoints.sort((a, b) => b.raw - a.raw);
        
        // 각 후보자 항목 추가 (내림차순 정렬된 데이터 사용)
        sortedDataPoints.forEach((dataPoint) => {
          const candidate = dataPoint.dataset.label;
          const value = dataPoint.raw; // raw 값은 숫자 형태
          const color = dataPoint.dataset.borderColor;
          
          // 후보자 항목 컨테이너
          const candidateItem = document.createElement('div');
          candidateItem.style.display = 'flex';
          candidateItem.style.alignItems = 'center';
          candidateItem.style.gap = '8px';
          
          // 이미지 또는 색상 원 표시
          const iconContainer = document.createElement('div');
          iconContainer.style.width = '24px';
          iconContainer.style.height = '24px';
          iconContainer.style.position = 'relative';
          
          // 이미지 캐시에서 이미지 불러오기
          const cachedImg = candidateImagesCache[candidate];
          
          if (cachedImg && cachedImg !== 'error') {
            // 이미지 컨테이너 (원 모양)
            iconContainer.style.borderRadius = '50%';
            iconContainer.style.overflow = 'hidden';
            iconContainer.style.border = `2px solid ${color}`;
            
            // 이미지 요소
            const imgElement = document.createElement('img');
            imgElement.src = candidateImages[candidate];
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.objectFit = 'cover';
            
            iconContainer.appendChild(imgElement);
          } else {
            // 이미지가 없으면 원형 색상 표시
            iconContainer.style.backgroundColor = color;
            iconContainer.style.borderRadius = '50%';
          }
          
          // 후보자 이름 및 값
          const textContainer = document.createElement('div');
          textContainer.style.display = 'flex';
          textContainer.style.justifyContent = 'space-between';
          textContainer.style.flex = '1';
          
          const nameElement = document.createElement('span');
          nameElement.textContent = candidate;
          nameElement.style.fontWeight = '500';
          
          const valueElement = document.createElement('span');
          valueElement.textContent = value + '%'; // '%' 기호 명시적으로 추가
          valueElement.style.fontWeight = 'bold';
          
          textContainer.appendChild(nameElement);
          textContainer.appendChild(valueElement);
          
          candidateItem.appendChild(iconContainer);
          candidateItem.appendChild(textContainer);
          
          bodyContainer.appendChild(candidateItem);
        });
        
        tooltipRoot.appendChild(bodyContainer);
      }

      // 모바일 화면인지 확인
      const isMobile = window.innerWidth <= 768;
      
      // 툴팁 위치 및 표시 설정 수정
      const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;
      
      tooltipEl.style.opacity = 1;
      tooltipEl.style.left = positionX + tooltip.caretX + 'px';
      
      if (isMobile) {
        // 모바일에서는 커서 아래에 표시
        tooltipEl.style.top = positionY + tooltip.caretY + 20 + 'px';
        tooltipEl.style.transform = 'translate(-50%, 0)';
        
        // 모바일에서 툴팁 크기 조정
        tooltipEl.style.maxWidth = '80vw';
        tooltipEl.style.minWidth = '160px';
        tooltipEl.style.fontSize = '12px';
      } else {
        // 데스크톱에서는 기존 방식대로 위에 표시
        tooltipEl.style.top = positionY + tooltip.caretY + 10 + 'px';
        tooltipEl.style.transform = 'translate(-50%, -110%)';
      }
    };

    // 툴팁 요소 생성 또는 가져오기 - 모바일 대응
    const getOrCreateTooltip = (chart) => {
      let tooltipEl = document.getElementById('chartjs-tooltip');
      
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip';
        tooltipEl.style.background = 'rgba(255, 255, 255, 0.95)';
        tooltipEl.style.borderRadius = '5px';
        tooltipEl.style.color = '#333';
        tooltipEl.style.opacity = 0;
        tooltipEl.style.pointerEvents = 'none';
        tooltipEl.style.position = 'absolute';
        tooltipEl.style.transition = 'all .1s ease';
        tooltipEl.style.minWidth = '200px';
        tooltipEl.style.padding = '10px';
        tooltipEl.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
        tooltipEl.style.zIndex = '999';
        
        // 모바일에서 툴팁이 화면 밖으로 벗어나지 않도록 설정
        tooltipEl.style.maxWidth = window.innerWidth <= 768 ? '80vw' : 'none';
        
        const tooltipContent = document.createElement('div');
        tooltipContent.className = 'tooltip-content';
        tooltipEl.appendChild(tooltipContent);
        
        document.body.appendChild(tooltipEl);
      }
      
      return tooltipEl;
    };

    // 차트를 그리는 함수
    function renderChart(rows) {
      // (1) X축 라벨로 사용할 배열 (date_day)
      const labels = [];
      // 원본 날짜 데이터 저장 배열 추가
      const originalDates = [];

      // (2) 후보자별 데이터 저장용 객체
      //     예: { "이재명": [], "김동연": [], ... }
      const candidateDataMap = {};
      candidateLabels.forEach(candidate => {
        candidateDataMap[candidate] = [];
      });

      // 데이터를 역순으로 처리하기 전에 원본 배열 복사
      const sortedRows = [...rows].reverse();

      // (3) CSV 각 행을 순회하며, date_day와 후보자 퍼센트를 추출
      // 데이터를 역순으로 처리하여 오래된 날짜부터 최신 날짜 순으로 정렬
      sortedRows.forEach(row => {
        // A. X축 라벨: row["date_day"] (예: "2025-03-10")
        const dateDay = row["date_day"];
        // 원본 날짜 저장
        originalDates.push(dateDay);
        // 날짜 포맷팅 (M/D(ddd))
        const formattedDate = dayjs(dateDay).format('M/D(ddd)');
        labels.push(formattedDate);

        // B. 후보자별 퍼센트 값을 숫자로 변환
        candidateLabels.forEach(candidate => {
          // 예: row["이재명"]가 "44%" 형태라면, "%" 제거 후 parseFloat
          const rawValue = row[candidate] || "0%";
          const numericValue = parseFloat(rawValue.replace("%", "")) || 0;
          candidateDataMap[candidate].push(numericValue);
        });
      });

      // (4) Chart.js에 사용할 datasets 배열 생성
      const datasets = candidateLabels.map(candidate => {
        const dataset = {
          label: candidate,
          data: candidateDataMap[candidate],
          fill: false,
          borderWidth: 4,
          borderColor: candidateColors[candidate],
          backgroundColor: candidateColors[candidate],
          tension: 0.2,
          pointRadius: new Array(candidateDataMap[candidate].length).fill(4),
          pointHoverRadius: 10,
          borderDash: candidateStyles[candidate].borderDash,
          pointStyle: candidateStyles[candidate].pointStyle,
          hidden: !visibleCandidates.includes(candidate)
        };

        // 최신 데이터 포인트 강조
        if (dataset.data.length > 0) {
          dataset.pointRadius[dataset.data.length - 1] = 6;
          dataset.pointBorderWidth = new Array(dataset.data.length).fill(1.5);
          dataset.pointBorderWidth[dataset.data.length - 1] = 3;
          dataset.pointBackgroundColor = new Array(dataset.data.length).fill(dataset.backgroundColor);
          dataset.pointBackgroundColor[dataset.data.length - 1] = body.classList.contains('dark-mode') ? '#ffffff' : '#ffffff';
        }

        return dataset;
      });

      // (5) 차트 생성 또는 업데이트
      const ctx = document.getElementById('electionChart').getContext('2d');
      
      // 최대값 계산
      let maxValue = 0;
      candidateLabels.forEach(candidate => {
        const candidateMax = Math.max(...candidateDataMap[candidate]);
        maxValue = Math.max(maxValue, candidateMax);
      });

      // Y축 최대값 설정 (기본 50%, 데이터가 50% 초과시 올림하여 설정)
      const yAxisMax = maxValue > 50 ? Math.ceil(maxValue / 10) * 10 : 50;

      if (chart) {
        // 기존 차트 업데이트
        chart.data.labels = labels;
        chart.data.datasets = datasets;
        chart.data.originalDates = originalDates; // 원본 날짜 데이터 업데이트
        chart.options.scales.y.max = yAxisMax;
        chart.update();
      } else {
        // 다크모드 여부에 따른 차트 색상 설정
        const isDarkMode = body.classList.contains('dark-mode');
        const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const textColor = isDarkMode ? '#e0e0e0' : '#333';
        const tickColor = isDarkMode ? '#adb5bd' : '#666';
        
        // 차트 옵션 설정
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            title: {
              display: true,
              text: '후보자별 검색 비율(%)',
              font: {
                size: 16,
                weight: 'bold'
              },
              padding: {
                top: 10,
                bottom: 20
              },
              color: textColor
            },
            tooltip: {
              enabled: false,  // 기본 툴팁 비활성화
              external: externalTooltipHandler,  // 커스텀 툴팁 사용
              mode: 'index',
              intersect: false
            },
            // datalabels 플러그인 비활성화 (중복 툴팁 방지)
            datalabels: {
              display: false
            }
          },
          scales: {
            x: {
              ticks: {
                color: tickColor,
                maxRotation: 45,
                minRotation: 45,
                font: {
                  size: 11
                },
                autoSkip: true,
                autoSkipPadding: 10
              },
              grid: {
                display: false
              }
            },
            y: {
              ticks: {
                color: tickColor,
                font: {
                  size: 11
                },
                callback: function(value) {
                  return value + '%';
                }
              },
              grid: {
                display: false
              }
            }
          }
        };

        // Chart 객체 생성 시 플러그인 포함
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: datasets,
            originalDates: originalDates
          },
          options: chartOptions,
          plugins: [candidateLabelPlugin]
        });
      }
    }

    // 2. candidateLabelPlugin 추가
    // 차트 위에 후보자 이름을 표시하는 플러그인 정의
    const candidateLabelPlugin = {
      id: 'candidateLabels',
      beforeInit: (chart) => {
        // 차트가 처음 초기화될 때만 이미지 로드 (성능 개선)
        candidateLabels.forEach(candidate => {
          if (!candidateImagesCache[candidate]) {
            const img = new Image();
            img.src = candidateImages[candidate];
            img.onload = () => {
              candidateImagesCache[candidate] = img;
            };
            img.onerror = () => {
              console.log(`후보자 이미지 로드 실패: ${candidate}`);
              candidateImagesCache[candidate] = 'error'; 
            };
          }
        });
      },
    };

    function setDateRange(days) {
      const endDate = new Date(allData[0]["date_day"]);
      const startDate = new Date(endDate);
      startDate.setDate(endDate.getDate() - days);

      document.getElementById('startDate').value = formatDate(startDate);
      document.getElementById('endDate').value = formatDate(endDate);

      applyDateFilter();
    }
  </script>
</body>
</html>
